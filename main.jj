options{
    IGNORE_CASE = true;
}

PARSER_BEGIN(FreePascal)
import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;

public class FreePascal {
  public static void main(String args[]) throws ParseException, IOException, IllegalAccessException {
    FreePascal lex = new FreePascal(new FileInputStream(args[0]));
    Map<Integer, String> CONSTANTES = new HashMap<Integer, String>();
    Class<?> clazz = FreePascalConstants.class;
    Field[] fields = clazz.getFields();

    for (Field field : fields) {
      if (field.getType() == int.class) {
      int modifiers = field.getModifiers();
      if (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers)) {
          try {
              CONSTANTES.put(field.getInt(null), field.getName());
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
    }
  }
    // for(Token t = getNextToken(); t.kind != EOF; t = getNextToken()){
    //   System.out.println(CONSTANTES.get(t.kind)+ " "+t.image);
    // }
    lex.Program();
  }
}

PARSER_END(FreePascal)

SKIP: {
  " "
| "\t"
| "\n"
| "\r"
| "\r\n"
| <STAR_COMMENT: "(*" (~["*"])* "*)">
| <CURLY_BRACKETS_COMMENT: "{" (~["}"])* "}">
| <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])*>

}

// Turbo Pascal reserved words
TOKEN: {
  <RESERVED_ABSOLUTE: "absolute">
| <RESERVED_AND: "and">
| <RESERVED_ARRAY: "array">
| <RESERVED_ASM: "asm">
| <RESERVED_BEGIN: "begin">
| <RESERVED_CASE: "case">
| <RESERVED_CONST: "const">
| <RESERVED_CONSTRUCTOR: "constructor">
| <RESERVED_DESTRUCTOR: "destructor">
| <RESERVED_DIV: "div">
| <RESERVED_DO: "do">
| <RESERVED_DOWNTO: "downto">
| <RESERVED_ELSE: "else">
| <RESERVED_END: "end">
| <RESERVED_FILE: "file">
| <RESERVED_FOR: "for">
| <RESERVED_FUNCTION: "function">
| <RESERVED_GOTO: "goto">
| <RESERVED_IF: "if">
| <RESERVED_IMPLEMENTATION: "implementation">
| <RESERVED_IN: "in">
| <RESERVED_INHERITED: "inherited">
| <RESERVED_INLINE: "inline">
| <RESERVED_INTERFACE: "interface">
| <RESERVED_LABEL: "label">
| <RESERVED_MOD: "mod">
| <RESERVED_NIL: "nil">
| <RESERVED_NOT: "not">
| <RESERVED_OBJECT: "object">
| <RESERVED_OF: "of">
| <RESERVED_OPERATOR: "operator">
| <RESERVED_OR: "or">
| <RESERVED_PACKED: "packed">
| <RESERVED_PROCEDURE: "procedure">
| <RESERVED_PROGRAM: "program">
| <RESERVED_RECORD: "record  ">
| <RESERVED_REINTRODUCE: "reintroduce">
| <RESERVED_REPEAT: "repeat">
| <RESERVED_SELF: "self">
| <RESERVED_SET: "set">
| <RESERVED_SHL: "shl">
| <RESERVED_SHR: "shr">
| <RESERVED_STRING: "string">
| <RESERVED_THEN: "then">
| <RESERVED_TO: "to">
| <RESERVED_TYPE: "type">
| <RESERVED_UNIT: "unit">
| <RESERVED_UNTIL: "until">
| <RESERVED_USES: "uses">
| <RESERVED_VAR: "var">
| <RESERVED_WHILE: "while">
| <RESERVED_WITH: "with">
| <RESERVED_XOR: "xor">
}

// Object Pascal reserved words
TOKEN: {
  <RESERVED_AS: "as">
| <RESERVED_CLASS: "class">
| <RESERVED_DISPINTERFACE: "dispinterface">
| <RESERVED_EXCEPT: "except">
| <RESERVED_EXPORTS: "exports">
| <RESERVED_FINALIZATION: "finalization">
| <RESERVED_FINALLY: "finally">
| <RESERVED_INITIALIZATION: "initialization">
| <RESERVED_IS: "is">
| <RESERVED_LIBRARY: "library">
| <RESERVED_ON: "on">
| <RESERVED_OUT: "out">
| <RESERVED_PROPERTY: "property">
| <RESERVED_RAISE: "raise">
| <RESERVED_RESOURCESTRING: "resourcestring">
| <RESERVED_THREADVAR: "threadvar">
| <RESERVED_TRY: "try">
}

// Modfiers reserved
TOKEN: {
  <RESERVED_ABSTRACT: "abstract">
| <RESERVED_ALIAS: "alias">
| <RESERVED_ASSEMBLER: "assembler">
| <RESERVED_BITPACKED: "bitpacked">
| <RESERVED_BREAK: "break">
| <RESERVED_CDECL: "cdecl">
| <RESERVED_CONTINUE: "continue">
| <RESERVED_CPPDECL: "cppdecl">
| <RESERVED_CVAR: "cvar">
| <RESERVED_DEFAULT: "default">
| <RESERVED_DEPRECATED: "deprecated">
| <RESERVED_DYNAMIC: "dynamic">
| <RESERVED_ENUMERATOR: "enumerator">
| <RESERVED_EXPERIMENTAL: "experimental">
| <RESERVED_EXPORT: "export">
| <RESERVED_EXTERNAL: "external">
| <RESERVED_FAR: "far">
| <RESERVED_FAR16: "far16">
| <RESERVED_FORWARD: "forward">
| <RESERVED_GENERIC: "generic">
| <RESERVED_HELPER: "helper">
| <RESERVED_IMPLEMENTS: "implements">
| <RESERVED_INDEX: "index">
| <RESERVED_INTERRUPT: "interrupt">
| <RESERVED_IOCHECK: "iocheck">
| <RESERVED_LOCAL: "local">
| <RESERVED_MESSAGE: "message">
| <RESERVED_NAME: "name">
| <RESERVED_NEAR: "near">
| <RESERVED_NODEFAULT: "nodefault">
| <RESERVED_NORETURN: "noreturn">
| <RESERVED_NOSTACKFRAME: "nostackframe">
| <RESERVED_OLDFPCCALL: "oldfpccall">
| <RESERVED_OTHERWISE: "otherwise">
| <RESERVED_OVERLOAD: "overload">
| <RESERVED_OVERRIDE: "override">
| <RESERVED_PASCAL: "pascal">
| <RESERVED_PLATFORM: "platform">
| <RESERVED_PRIVATE: "private">
| <RESERVED_PROTECTED: "protected">
| <RESERVED_PUBLIC: "public">
| <RESERVED_PUBLISHED: "published">
| <RESERVED_READ: "read">
| <RESERVED_REGISTER: "register">
| <RESERVED_RESULT: "result">
| <RESERVED_SAFECALL: "safecall">
| <RESERVED_SAVEREGISTERS: "saveregisters">
| <RESERVED_SOFTFLOAT: "softfloat">
| <RESERVED_SPECIALIZE: "specialize">
| <RESERVED_STATIC: "static">
| <RESERVED_STDCALL: "stdcall">
| <RESERVED_STORED: "stored">
| <RESERVED_STRICT: "strict">
| <RESERVED_UNALIGNED: "unaligned">
| <RESERVED_UNIMPLEMENTED: "unimplemented">
| <RESERVED_VARARGS: "varargs">
| <RESERVED_VIRTUAL: "virtual">
| <RESERVED_WINAPI: "winapi">
| <RESERVED_WRITE: "write">
}

SPECIAL_TOKEN: {
  <AMPERSAND: "&">
}

// Digits
TOKEN: {
  <#DIGIT: "0" | <NON_ZERO_DIGIT> >
| <#NON_ZERO_DIGIT: ["1"-"9"]>
| <#HEX_DIGIT: <DIGIT> | ["A"-"F"] | ["a"-"f"]>
| <#OCTAL_DIGIT: ["0"-"7"]>
| <#BINARY_DIGIT: ["0","1"]>
| <#SIGN: "+" | "-">
| <#SCALE_FACTOR: ("E" | "e") (<SIGN>)? (<DIGIT>)+ >
|  <REAL: (<SIGN>)? (<DIGIT_SEQUENCE>)+ "." (<DIGIT_SEQUENCE>)* (<SCALE_FACTOR>)? >
|  <HEX_DIGIT_SEQUENCE: (<SIGN>)? "$" (<HEX_DIGIT>)+ >
|  <OCTAL_DIGIT_SEQUENCE: (<SIGN>)? "&" (<OCTAL_DIGIT>)+ >
|  <BINARY_DIGIT_SEQUENCE: (<SIGN>)? "%" (<BINARY_DIGIT>)+ >
|  <#DIGIT_SEQUENCE: <DIGIT> (<DIGIT>)* >
|  <DECIMAL_SEQUENCE: (<SIGN>)? <DIGIT> (<DIGIT>)* >
| <#UNSIGNED_INTEGER: <HEX_DIGIT_SEQUENCE>
                      | <OCTAL_DIGIT_SEQUENCE>
                      | <BINARY_DIGIT_SEQUENCE>
                      | <DIGIT_SEQUENCE> >
}

// Compound symbols
TOKEN:
{
  <NOT_EQUALS: "!=">
| <DOUBLE_LEFT_ARROW: "<<">
| <DOUBLE_RIGHT_ARROW: ">>">
| <LEFT_RIGHT_ARROW: "<>">
| <RIGHT_LEFT_ARROW: "><">
| <LESS_THAN_OR_EQUALS: "<=">
| <GREATHER_THAN_OR_EQUALS: ">=">
| <ASSIGMENT: ":=">
| <PLUS_EQUALS: "+=">
| <MINUS_EQUALS: "-=">
| <TIMES_EQUALS: "*=">
| <SLASH_EQUALS: "/=">
| <OPEN_PARENTHESIS_DOT: "(.">
| <DOT_CLOSE_PARENTHESIS: ".)">
}

// Special symbols
TOKEN:
{
  <SEMI: ";">
| <PLUS: "+">
| <MINUS: "-">
| <ASTERISK: "*">
| <SLASH: "/">
| <EQUALS: "=">
| <LESS_THAN: "<">
| <GREATER_THAN: ">">
| <OPEN_BRACKETS: "[">
| <CLOSE_BRACKETS: "]">
| <DOT: ".">
| <COMMA: ",">
| <OPEN_PARENTHESIS: "(">
| <CLOSE_PARENTHESIS: ")">
| <COLON: ":">
| <CARET: "^">
| <AT: "@">
}

// Strings
TOKEN: {
  <#STRING_CHARACTER: [" " - "&", "(" - "~"] >
| <#CONTROL_STRING: "#" <UNSIGNED_INTEGER> >
| <#QUOTETED_STRING: "'" (<STRING_CHARACTER>)* "'" >
| <CHARACTER_STRING: ( <QUOTETED_STRING> | <CONTROL_STRING> )+ >
}

// Letter
TOKEN: {
  <#LETTER: <LOWER> | <UPPER> >
| <#LOWER: ["a"-"z"]>
| <#UPPER: ["A"-"Z","_"]>
}

// Identifiers
TOKEN: {
  <IDENTIFIER: (<AMPERSAND>)? <LETTER> (<LETTER> | <DIGIT>)* > 
}


// Labels
TOKEN: {
  <#LABEL: <DIGIT_SEQUENCE> | <IDENTIFIER> >
}


void Program(): {} {
  <RESERVED_PROGRAM> <IDENTIFIER> <SEMI> Block()
}

void Block(): {} {
  DeclarationPart() StatementPart()
}

void DeclarationPart(): {} {
  ((ConstantDeclarationPart() | TypeDeclarationPart() | VariableDeclarationPart() | FunctionDeclarationPart())?)*
}

void ConstantDeclarationPart(): {} {
  <RESERVED_CONST> ( ConstantDeclaration() | TypedConstatDeclaration())*
}

void TypeDeclarationPart(): {} {
  <RESERVED_TYPE> TypeDeclaration()*
}

void VariableDeclarationPart(): {} {
  <RESERVED_VAR> VariableDeclaration()*
}

void FunctionDeclarationPart(): {} {
  FunctionDeclaration()*
}

void StatementPart(): {} {
  CompoundStatement()
}

void Statement(): {} {
  (SimpleStatement() | StructuredStatement())?
}

void SimpleStatement(): {} {
  AssignmentStatement() | ProcedureStatement()
}

void AssignmentStatement(): {} {
  (VariableReference() | FunctionIdentifier())  (<ASSIGMENT> | <PLUS_EQUALS> | <MINUS_EQUALS> | <TIMES_EQUALS> | <SLASH_EQUALS>) Expression()
}

void StructuredStatement(): {} {
  CompoundStatement() | ConditionalStatement() | RepetitiveStatement()
}

void ConditionalStatement(): {} {
  IfStatement()
}

void RepetitiveStatement(): {} {
  WhileStatement()
}

void IfStatement(): {} {
  <RESERVED_IF> Expression() <RESERVED_THEN> Statement() (<RESERVED_ELSE> Statement())?
}

void WhileStatement(): {} {
  <RESERVED_WHILE> Expression() <RESERVED_DO> Statement()
}

void Expression(): {} {
  SimpleExpression() (( <LESS_THAN> | <LESS_THAN_OR_EQUALS> | <GREATER_THAN> | <GREATHER_THAN_OR_EQUALS> | <EQUALS> | <LEFT_RIGHT_ARROW> | <RESERVED_IN> | <RESERVED_IS>) SimpleExpression())?
}

void SimpleExpression(): {} {
  Term() ((<PLUS> | <MINUS> | <RESERVED_OR> | <RESERVED_XOR>) Term())*
}

void Term() :{}
{
  Factor() (<ASTERISK> | <DIV> | <MOD> | <AND> ) factor()*
}

void Factor() :{}
{
  ID (<LBRACE> Expression() <RBRACE>)?
  |
  <NUM>
  |
  <LPAREN> expression() <RPAREN>
  |
  (<ADD> | <SUB> | <NOT>) factor()
}


// void Exp(): {}{
//   <IDENTIFIER>  | <REAL> | <CHARACTER_STRING>
// }


// /*
//  * Ordinary constants
//  */

// void Constant_declaration(): {}{
//   <IDENTIFIER> = Expression() HintDirectives();
// }

// void Typed_constant_declaration(): {}{
//   <IDENTIFIER> = Type() Typed_constant() HintDirectives();
// }

// void Typed_constant(): {}{
//   Constant() | Adress_Constant() | ArrayConstant() | Record_Constant() | ProceduralConstant();
// }

// /*
//  * Base types
//  */



// void Program_parameter(): {}{
  
// }

// void Program_header(): {}{
//   <RESERVED_PROGRAM> <IDENTIFIER> ()
// } 

// void Programs(): {}{
//   <IDENTIFIER>  | <REAL> | <CHARACTER_STRING>
// }





////////////////////
//operator definition




// void Operator_Definition(): {} {
//   <RESERVED_OPERATOR> (Assignment_operator_definition() | Arithmetic_operator_definition() | Comparison_operator_definition() | Logical_operator_definition() | Other_operator_definition() )
// }





// //procedure and functions

// void  Constant_Parameter(): {} {
//   <RESERVERD_CONST> (Identifier_list() (<COLON> (<RESERVED_ARRAY> <RESERVED_OF>)? Type_Identifier() )?  ) | (<IDENTIFIER> <COLON> Type_Identifier() <EQUALS> Default_Parameter_Value())
// }

// void  Out_Parameter(): {} {
//   <RESERVERD_OUT> Identifier_list() (<COLON> (<RESERVED_ARRAY> <RESERVED_OF>)? Type_Identifier() )?   
// }


// void  Variable_Parameter(): {} {
//   <RESERVERD_VAR> Identifier_list() (<COLON> (<RESERVED_ARRAY> <RESERVED_OF>)? Type_Identifier() )?   
// }

//  void ValueParameter(): {} {
//   (Identifier_list() <COLON> (<RESERVED_ARRAY> <OF>)? Parameter_Type() )| (<IDENTIFIER> <COLON> Type_Identifier() <EQUALS> Default_Parameter_Value())
// }
// void ParameterDeclaration(): {} {
//   ValueParameter() | VariableParameter() | OutParameter() | ConstantParameter()
// }

// void  Formal_Parameter_List(): {} {
//   <OPEN_PARENTHESIS> ParameterDeclaration() (<SEMI> ParameterDeclaration())* <CLOSE_PARENTHESIS>
// }
//  void Function_declaration(): {} {
//   Function_header() <SEMI> Subroutine_block() <SEMI>
// }
// void  Function_header(): {} {
//   <RESERVED_FUNCTION> <IDENTIFIER> Qualified_method_identifier()

// void FormalParameterList(): {} {
//   <COLON> ResultType() (Modifers())? HintDirectives()
// }



// void procedureDeclaration(): {} {
//   ProcedureHeader() <SEMI> Subroutine_block() <SEMI>
// }


// void ProcedureHeader(): {} {
//   <RESERVED_PROCEDURE> <IDENTIFIER> | Qualified_method_identifier()
// }


// void FormalParameterList(): {} {
//   (Modifiers())? HintDirectives()
// }



// void Subroutine_block(): {} {
//   Block()
// }





// //statements

// void While_statement(): {} {
//   <RESERVED_WHILE> Expression() <RESERVED_DO> Statement()
// }


// void If_statement(): {} {
//   <RESERVED_IF> Expression() <RESERVED_THEN> Statement() (<RESERVED_ELSE> Statement())?
// }


// void Compound_statement(): {} {
//   <RESERVED_BEGIN> Statement() (<SEMI> Statement())*  <RESERVED_END>
// }

// void Repetitive_statement(): {} {
//   For_statement() | For_In_statement() | Repeat_statement() | While_statement()
// }

// void Conditional_statement(): {} {
//   Case_Statement() | If_Statement()
// }


// void Structured_statement(): {} {
//   Compound_statement() | Conditional_statement() | Repetitive_statement()
// }



// void Goto_statement(): {} {
//   <RESERVED_GOTO> <LABEL>
// }


// void Procedure_statement(): {} {
//   Procedure_Identifier() | Method_identifier() | Qualified_method_identifier() | Variable_reference() (ActualParameterList())*
// }


// void Assignment_statement(): {} {
//   (Variable_reference() | Function_identifier()) (<ASSIGMENT> | <PLUS_EQUALS> | <MINUS_EQUALS> | <TIMES_EQUALS> | <SLASH_EQUALS>) Expression()
// }



// void Simple_statement(): {} {
//   Assignment_statement() | Procedure_statement() | Goto_statement() | Raise_Statement()
// }


// void statement(): {} {
//   (<label> <COLON>)* (Simple_statement() | Structured_statement())*
// }



// //12.1 expressions
// void ActualParameterList(): {}{
//   <OPEN_PARENTHESIS> (Expression() <COMMA>)* <CLOSE_PARENTHESIS>
// }

// void Function_call(): {}{
//   (Function_identifier() | Variable_reference()) ActualParameterList()
// }


// void Unsigned_constant(): {}{
//   <UNSIGNED_NUMBER> | <CHARACTER_STRING> | Constant_Identifier() | <RESERVED_NIL>
// }

// void Factor(): {}
// {
//   <OPEN_PARENTHESIS> Expression() <CLOSE_PARENTHESIS> | Variable_reference() | Function_call() | UnsignedConstant() | <RESERVED_NOT> Factor | <SIGN> Factor()  
// }
// void Term(): {}{
//   Factor() <ASTERISK> | <SLASH> | <RESERVED_DIV> | <RESERVED_MOD> | <RESERVED_AND> | <RESERVED_SHL> | <RESERVED_SHR> | <RESERVED_AS>
// }

// void Simple_expression(): {}{
//   Term() <PLUS> | <MINUS> | <RESERVED_OR> | <RESERVED_XOR>
// }


// void Expression(): {}{
//   Simple_expression()
// }
